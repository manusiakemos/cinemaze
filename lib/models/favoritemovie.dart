/*
  THIS CLASS IS AUTOGENERATED
  You shouldn't modify it manually 
  For creating or modifying models you can create a descriptor and run craftman:scaffold command
 */
import 'package:intl/intl.dart';
import 'package:loquacious/loquacious.dart';

/* 
  The FavoriteMovie model class
 */
class FavoriteMovie {
  /* 
    BASE PROPERTIES
   */

  // table name
  String _table = 'FAVORITE_MOVIES';
  String get table => _table;

  // primary key of the table
  static const String _primaryKey = 'id';

  // arguments of the model representing the table columns
  Map<String, dynamic> arguments = {
    'id': null,
    'title': null, 'poster_path': null, 'popularity': null,
    'created_at': null,
    'updated_at': null,
  };

  /* 
    ARGUMENTS PROPERTIES
   */
    
  // primary key property
  int get id => arguments['id'];
  set id(int value) {
    arguments['id'] = value;
  }

  // title property
  String get title => arguments['title'];
  set title(String value) {
    arguments['title'] = value;
  }

  // poster_path property
  String get posterPath => arguments['poster_path'];
  set posterPath(String value) {
    arguments['poster_path'] = value;
  }

  // popularity property
  String get popularity => arguments['popularity'];
  set popularity(String value) {
    arguments['popularity'] = value;
  }

  // created at timestamp property
  DateTime get createdAt => DateTime.parse(arguments['created_at']);
  set createdAt(DateTime value) {
    arguments['created_at'] = DateFormat('yyy-MM-dd H:m:s').format(value);
  }

  // updated at timestamp property
  DateTime get updatedAt => DateTime.parse(arguments['updated_at']);
  set updatedAt(DateTime value) {
    arguments['updated_at'] = DateFormat('yyy-MM-dd H:m:s').format(value);
  }

  /* 
    CONSTRUCTOR
   */
  FavoriteMovie({
    int id,
    String title, String posterPath, String popularity,
  }) {
    this.id = id;
    this.title = title; this.posterPath = posterPath; this.popularity = popularity;
  }

  /* 
    UTILITY METHODS
   */

  // MAP METHOD
  static FavoriteMovie mapToModel(dynamic e) {
    final el = Map<String, dynamic>.from(e);
    final m = FavoriteMovie(
      id: el['id'],
      title: el['title'], posterPath: el['poster_path'], popularity: el['popularity'],
    );
    m.arguments['created_at'] = el['created_at'];
    m.arguments['updated_at'] = el['updated_at'];
    return m;
  }

  /* 
    CREATE
    instantiate a new FavoriteMovie, save it do DB and returns it
   */
  static Future<FavoriteMovie> create({
    int id, 
    String title, String posterPath, String popularity,
  }) async {
    final m = FavoriteMovie();
    m.id = id;
    m.title = title; m.posterPath = posterPath; m.popularity = popularity;
    await m.save();
    return m;
  }

  /* 
    ALL
    returns the whole collection of FavoriteMovie model
   */
  static Future<List<FavoriteMovie>> all() async {
    return _LQBM<FavoriteMovie>.table('FAVORITE_MOVIES').get();
  }

  /* 
    FIND
    find a FavoriteMovie model and returns it if found, else return null
   */
  static Future<FavoriteMovie> find(int id) async {
    return await _LQBM<FavoriteMovie>.table('FAVORITE_MOVIES').where(FavoriteMovie._primaryKey, id).first();
  }

  /* 
    WHERE
    instantiate a Loquacious query builder of type FavoriteMovie, applies a where and returns it
   */
  static _LQBM<FavoriteMovie> where(
    String column,
    dynamic value, {
    String comparisonOperator,
  }) {
    return _LQBM<FavoriteMovie>.table('FAVORITE_MOVIES').where(
      column,
      value,
      comparisonOperator: comparisonOperator,
    );
  }

  /* 
    ORDER BY
    instantiate a Loquacious query builder of type FavoriteMovie, applies an order by and returns it
   */
  static _LQBM<FavoriteMovie> orderBy(String column) {
    return _LQBM<FavoriteMovie>.table('FAVORITE_MOVIES').orderBy(column);
  }

  /* 
    ORDER BY DESC
    instantiate a Loquacious query builder of type FavoriteMovie, applies an order by desc and returns it
   */
  static _LQBM<FavoriteMovie> orderByDesc(String column) {
    return _LQBM<FavoriteMovie>.table('FAVORITE_MOVIES').orderByDesc(column);
  }

  /* 
    GROUP BY
    instantiate a Loquacious query builder of type FavoriteMovie, applies a group by and returns it
   */
  static _LQBM<FavoriteMovie> groupBy(List<String> columns) {
    return _LQBM<FavoriteMovie>.table('FAVORITE_MOVIES').groupBy(columns);
  }

  /* 
    LIMIT
    instantiate a Loquacious query builder of type FavoriteMovie, applies a limit and returns it
   */
  static _LQBM<FavoriteMovie> limit(int count) {
    return _LQBM<FavoriteMovie>.table('FAVORITE_MOVIES').limit(count);
  }

  /* 
    TAKE
    instantiate a Loquacious query builder of type FavoriteMovie, applies a take and returns it
   */
  static _LQBM<FavoriteMovie> take(int count) {
    return _LQBM<FavoriteMovie>.table('FAVORITE_MOVIES').take(count);
  }

  /* 
    OFFSET
    instantiate a Loquacious query builder of type FavoriteMovie, applies an offset and returns it
   */
  static _LQBM<FavoriteMovie> offset(int count) {
    return _LQBM<FavoriteMovie>.table('FAVORITE_MOVIES').offset(count);
  }

  /* 
    SKIP
    instantiate a Loquacious query builder of type FavoriteMovie, applies a skip and returns it
   */
  static _LQBM<FavoriteMovie> skip(int count) {
    return _LQBM<FavoriteMovie>.table('FAVORITE_MOVIES').skip(count);
  }

  /* 
    SAVE
    save the FavoriteMovie model to DB
   */
  Future<FavoriteMovie> save() async {
    if (arguments.containsKey('created_at') && arguments['created_at'] == null) {
      createdAt = DateTime.now();
    }
    updatedAt = DateTime.now();

    if (arguments.containsKey(_primaryKey) && arguments[_primaryKey] == null) {
      arguments.removeWhere((key, value) => key == _primaryKey);
      int id = await LQB.table(_table).insertGetId(arguments);
      arguments['id'] = id;
    } else {
      await LQB.table(_table).where(_primaryKey, arguments['id']).update(arguments);
    }
    return this;
  }

  @override
  String toString() {
    return arguments.toString();
  }
}

/* 
 QUERY BUILDER OF FavoriteMovie MODEL
 */
class _LQBM<T extends FavoriteMovie> extends LQB {
  _LQBM.table(String tableName) : super.table(tableName);

  @override
  Future<List<FavoriteMovie>> get() async {
    return List<FavoriteMovie>.from((await this.getDynamic()).map(FavoriteMovie.mapToModel));
  }

  @override
  Future<FavoriteMovie> first() async {
    try {
      return List<FavoriteMovie>.from((await this.getDynamic()).map(FavoriteMovie.mapToModel)).first;
    } catch (e) {}
    return null;
  }
}